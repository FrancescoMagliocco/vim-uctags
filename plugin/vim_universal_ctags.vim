" A Vim plugin to highlight tags generated by Universal-Ctags
" Last Change:  2019-05-08
" Maintainer:   Francesco Magliocco
" License:      GNU General Public License v3.0

" We check if enabled first because if not enabled, it doesn't matter what
" version of Vim is running.
if exists('g:loaded_universal_ctags') && g:loaded_universal_ctags
  finish
endif

if v:version < 801
  echohl errorMsg
  echomsg 'Vim needs to be atleast version 8.1 to use this plugin'
  echohl None
endif

if exists('g:universal_ctags_enabled') && !g:universal_ctags_enabled
  echohl moreMsg | echomsg 'vim-universal-ctags is not enabled' | echohl None
  finish
endif

" XXX Using universal_ctags as prefixes for everything, and even the plugin,
"   kind of bothers me in a way such that what if universal-ctags actually
"   creates a plugin..
let g:loaded_universal_ctags        = 1

let g:universal_ctags_executable    =
      \ get(g:, 'universal_ctags_name', 'ctags-universal')

" COMBAK This name doesn't really 'flow'..
let g:universal_ctags_tags_name     =
      \ get(g:, 'universal_ctags_tags_name', 'tags')
let g:universal_ctags_max_info      = get(g:, 'universal_ctags_max_info', 1)

let g:universal_ctags_extra_args    = get(g:, 'universal_ctags_extra_args', {})

" universal ctags skip highlight for
" FIXME I don't like this name
" TODO Come up with more elaborate name
let g:universal_ctags_skip_hl_for   = get(
      \ g:,
      \ 'universal_ctags_skip_hl_for',
      \ {
      \   'function': ['vim']
      \ })

" universal ctags kind to highlight group
" The name for this is kind of relevant, but I'm not sure I like it..
let g:universal_ctags_kind_to_hlg   = get(
      \ g:,
      \ 'universal_ctags_kind_to_hlg',
      \ {
      \   'function': 'functionName',
      \   'method'  : 'methods'
      \ })

function! s:ParseArgs(args)
  return extend(extend(a:args, g:universal_ctags_max_info
        \   ? {
        \       '--fields=': '*',
        \       '--all-kinds=': '*'
        \     }
        \   : {} ), g:universal_ctags_extra_args)
endfunction

" This will define the default arguments.
let g:universal_ctags_args          = get(
      \ g:,
      \ 'universal_ctags_args',
      \ {
      \   '-R': '',
      \   '-f': g:universal_ctags_tags_name
      \ })

" Extends g:universal_ctags_args with g:universal_ctags_extra_args so
" g:universal_ctags_args can be used when needing arguments for
" ctags-universal.  See s:ParseArgs() body for aditional details.
let g:universal_ctags_args          = s:ParseArgs(g:universal_ctags_args)

let s:lang_map                      =
      \ {
      \   'c#'  : 'cSharp',
      \   'c++' : 'cpp'
      \ }

" highlight group map
let s:hlg_map                       =
      \ {
      \   'function'  : 'Func',
      \   'variable'  : 'Var',
      \ }

" universal ctags highlight group map
" FIXME The name for this isn't exactly relevant..
" TODO Come up with more elaborate name.
" This is more of a 'kind to kind but truncated' map.  So maybe rename it as
"   'g:universal_ctags_kind_map', plus it would match the naming convention
"   that was used for 'g:universal_ctags_lang_map'
let g:universal_ctags_hl_group_map  =
      \ get(g:, 'universal_ctags_hl_group_map', {})

let g:universal_ctags_lang_map      = get(g:, 'universal_ctags_lang_map', {})

" Any key in a:hlg_map that isn't in s:hlg_map will be removed.
" Create a deepcopy() of s:hlg_map, extend said copy with a:hlg_map.
" Remove any non-word character.
"function! s:ParseHlGMap(hlg_map)
""  return map(extend(deepcopy(s:hlg_map), filter(
""        \ a:hlg_map,
""        \ 'has_key(s:hlg_map, v:key)')), "substitute(v:val, '\W', '', 'g')")
""endfunction

" TODO Rename
function! s:ParseHlGMap(hlg_map, map)
  return map(extend(copy(a:map), a:hlg_map), "substitute(v:val, '\W', '', 'g')")
endfunction

" TODO Implement the same, but for g:universal_ctags_ctags_lang_map
let g:universal_ctags_hl_group_map  =
      \ s:ParseHlGMap(g:universal_ctags_hl_group_map, s:hlg_map)

augroup universal_ctags_aug
  autocmd!
  if filereadable(g:universal_ctags_tags_name)
    autocmd BufWritePost * silent call UCTags#Generate#GenTags()
  endif
augroup END

command! UpdateTags call silent UCTags#Generate#GenTags()
